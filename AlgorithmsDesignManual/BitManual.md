##位运算(bit manipulation)
###常用操作
	n&(n-1) //清除n的最后一位1
	(x^y) < 0 //判断x，y是否异号
	
###例题
问题一：

	1. 数组中仅有一个数出现1次，其他出现2次，求这个数
	负数怎么办？
思路：

	数组异或值
问题二：

	2. 数组中仅有一个数出现1次，其他出现3次，求这个数
思路：

	对于32位整数，每一位统计1出现的次数，他要么 %3 == 0， 要么 %3 == 1，
	%3 == 1 的必定是所求数的一位
问题三：

	3. 数组中仅有一个数出现m次，其他出现n次，n不是m的倍数，求这个数
思路：

	2的解法依然适用
	参考：https://discuss.leetcode.com/topic/22821/an-general-way-to-
	handle-all-this-sort-of-questions/12
问题四：

	4. 数组只有两个数出现一次，其他数出现2次，求这两个数
思路：

	数组异或完后是 a^b 的值，res位中为1的bit位，
	说明a,b在此位不同，依据此可以把数组分成两拨，含a的一组
	含b的一组，两组分别作异或即可
问题五：n&(n-1)的妙用

	a. 统计bit位中1的个数
	b. 判断数字是否是2的幂 n&(n-1) == 0

问题六：

	6. 求数组中所有pair对的汉明距离之和，数组很大
思路：

	考虑按位计数，统计每一位的1的个数m和0的个数n，
	m*n就是该位作出的贡献
问题七：

	7. m,n为正整数，m<n, 求区间[m,n] AND值
思路：

	按位考虑，奇数，偶数最后一位相与肯定为0，只要[m,n]区间大于1，必包含
	奇偶，0再与上任何0，1均为0，最后一位为0，同理，m，n同时左移一位接着
	判断，以此类推。实际上就是求m，n的相同前缀为1的长度
	
	while(m!=n){
		m <<= 1;
		n <<= 1;
		cnt++;
	}
	return m * (1 << cnt);
	
	//anothor
	while(n > m){
		n = n&(n-1);
	}
	return n;
问题八：

	8. 正整数n，求[1,n]每个数的1的个数，最好在O(n)复杂度

思路：

	找规律，递推，dp, 好多种递推方式
	f[i] = f[i >> 1] +（i&1）
问题九：

	9. 给定含有正整数的数组，求异或值最大的pair的值
思路：

	a. 逐位确定
	b. Tire查询
问题10:

	两个数的加法，用位运算写
思路：

	a. 模拟二进制加法
	b. 参考http://www.cnblogs.com/grandyang/p/5451942.html
	   两个数相加，不考虑进位的结果加上进位，是最终的结果
	   二进制下，不考虑进位加为异或，进位表示为AND，这样反复直到没有进位